# -*- coding: utf-8 -*-
"""LinearInsurance.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qs7ufF38pW6vWfSsYC0x09zzBS_phcse
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np

class LinearModel:
    def __init__(self, num_features):
        self.num_features = num_features
        self.W = np.random.randn(num_features, 1)
        self.b = np.random.randn()
        
    def forward_pass(self, X):
        y = self.b + np.dot(X, self.W)
        return y
    
    def compute_loss(self, y, y_true):
        loss = np.sum(np.square(y - y_true))
        return loss/(2*y.shape[0])
    
    def backward_pass(self, X, y_true, y_hat):
        m = y_hat.shape[0]
        db = np.sum(y_hat - y_true)/m
        dW = np.sum(np.dot(np.transpose(y_hat - y_true), X), axis=0)/m
        return dW, db
    
    def update_params(self, dW, db, lr):
        self.W = self.W - lr * np.reshape(dW, (self.num_features, 1))
        self.b = self.b - lr * db
        
    def train(self, x_train, y_train, iterations, lr):
        losses = []
        for i in range(iterations):
            y_hat = self.forward_pass(x_train)
            dW, db = self.backward_pass(x_train, y_train, y_hat)
            self.update_params(dW, db, lr)
            loss = self.compute_loss(y_hat, y_train)
            losses.append(loss)
            if i % int(iterations/10) == 0:
                print('Iter: {}, Current loss: {:.4f}'.format(i, loss))
        return losses

    def split_sets(x):
      test_size = int(0.7 * len(x))
      return x[0: test_size], x[test_size:len(x)] # test, train

import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('/content/drive/MyDrive/TEC_10_Sem/insurance_3.csv')



df.loc[(df['sexf'] == 'female') , 'sexf'] = 1.0
df.loc[(df['sexf'] == 'male') , 'sexf'] = 0.0
df.loc[(df['sexm'] == 'female') , 'sexm'] = 0.0
df.loc[(df['sexm'] == 'male') , 'sexm'] = 1.0
df.loc[(df['smoker'] == 'yes') , 'smoker'] = 1.0
df.loc[(df['smoker'] == 'no') , 'smoker'] = 0.0



df.head()

df2=df
df2=df.apply(pd.to_numeric, errors="ignore")
df2.dtypes

print(df2)

df2.corr()



#Get Features
print(df2)
x1 = df2.age.values
x2 = df2.bmi.values
x5 = df2.smoker.values

x = np.array([x1,x2,x5]).transpose()
#Get Y
y = df2.charges.values
y = np.reshape(y, (y.shape[0], 1))

model = LinearModel(3)


x_test, x_train = LinearModel.split_sets(x)
y_test, y_train = LinearModel.split_sets(y)



losses = model.train(x_train, y_train,7000, 0.000001)

plt.plot(losses)
plt.show()

print(model.W, model.b)

y_preds = model.forward_pass(x_test)
model.compute_loss(y_preds, y_test)

plt.plot(range(len(y_test)), y_test, 'r.', label='Test', alpha=.5)
plt.plot(range(len(y_test)), y_preds, 'b.', label='Predictions',alpha=.5)
plt.legend()
plt.xlabel('# of instance')
plt.ylabel('Performance')
plt.show()

print("Edad")
Edad=  float(input())

print("BMI")
BMI=  float(input())
print("Smoker")
Smoker=  float(input())

y_predict=np.array([Edad,BMI,Smoker]).transpose()
y_predict=model.forward_pass(y_predict)
print(y_predict)

print("Edad")
Edad=  float(input())

print("BMI")
BMI=  float(input())
print("Smoker")
Smoker=  float(input())

y_predict=np.array([Edad,BMI,Smoker]).transpose()
y_predict=model.forward_pass(y_predict)
print(y_predict)

from sklearn import datasets, linear_model
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score
# fit a model
lm = linear_model.LinearRegression()
model = lm.fit(x_train, y_train)
predictions = lm.predict(x_test)

# The line / model
plt.scatter(y_test, predictions)
plt.xlabel('True Values')
plt.ylabel('Predictions')

print ('Score: ', model.score(x_test, y_test))
print (r2_score(y_test, predictions))

print("Edad")
Edad=  float(input())
print("BMI")
BMI=  float(input())
print("Smoker")
Smoker=  float(input())
y_predict=np.array([[Edad,BMI,Smoker]])
y_predict=lm.predict(y_predict)
print(y_predict)